# -*- coding: utf-8 -*-
"""IVALAB2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yGlrgdb6rZG-nebhstent64mLp3PFd59
"""

pip install ffmpeg-python

"""Lab Task 1: Setup and Basic Extraction

Objective:

Install the necessary tools and libraries, and extract frame information from a video.

Steps:

1.	Install ffmpeg and ffmpeg-python:
o	Install the ffmpeg tool and the ffmpeg-python library.
2.	Extract Frame Information:
o	Extract frame information from a sample video.
"""

import ffmpeg

# Path to the video file
video_path = '/content/vid2.mp4'

# Get video information
probe = ffmpeg.probe(video_path)
video_info = next(stream for stream in probe['streams'] if stream['codec_type'] == 'video')

# Extract frame information
frame_rate = eval(video_info['r_frame_rate'])
duration = float(video_info['duration'])
total_frames = int(frame_rate * duration)
width = int(video_info['width'])
height = int(video_info['height'])

print(f"Frame Rate: {frame_rate} frames per second")
print(f"Duration: {duration} seconds")
print(f"Total Frames: {total_frames}")
print(f"Width: {width} pixels")
print(f"Height: {height} pixels")

"""Lab Task 2: Frame Type Analysis

Objective:

Analyze the extracted frame information to understand the distribution of I, P, and B frames in a video.

Steps:

1.Modify the Script:
oCount the number of I, P, and B frames.
oCalculate the percentage of each frame type in the video.

2.Analyze Frame Distribution:
oPlot the distribution of frame types using a library like matplotlib.
oPlot a pie chart or bar graph showing the distribution of frame types using matplotlib.
"""

import ffmpeg
import matplotlib.pyplot as plt

def count_frame_types(video_path):
    # Use ffmpeg to count I, P, and B frames
    result = ffmpeg.probe(video_path, select_streams='v', show_frames=None, show_entries='frame=pict_type')
    frames = result['frames']
    # Count the number of I, P, B frames
    frame_types = {'I': 0, 'P': 0, 'B': 0}
    for frame in frames:
        frame_type = frame['pict_type']
        frame_types[frame_type] += 1
    total_frames = sum(frame_types.values())
    percentages = {frame_type: (count / total_frames) * 100 for frame_type, count in frame_types.items()}
    print(f"I-Frames: {frame_types['I']} ({percentages['I']:.2f}%)")
    print(f"P-Frames: {frame_types['P']} ({percentages['P']:.2f}%)")
    print(f"B-Frames: {frame_types['B']} ({percentages['B']:.2f}%)")
    return frame_types, percentages
def plot_frame_distribution(frame_types, percentages):
    labels = ['I-Frames', 'P-Frames', 'B-Frames']
    counts = [frame_types['I'], frame_types['P'], frame_types['B']]
    percent_values = [percentages['I'], percentages['P'], percentages['B']]
    # Bar Plot
    plt.figure(figsize=(10, 5))
    plt.bar(labels, counts, color=['blue', 'yellow', 'red'])
    plt.xlabel('Frame Type')
    plt.ylabel('Count')
    plt.title('Frame Type Distribution')
    plt.show()

    # Pie Chart
    plt.figure(figsize=(8, 8))
    plt.pie(counts, labels=labels, autopct='%1.1f%%', colors=['blue', 'yellow', 'red'])
    plt.title('Frame Type Distribution')
    plt.show()
video_path = '/content/vid2.mp4'
# Count frame types and calculate percentages
frame_types, percentages = count_frame_types(video_path)
# Plot the distribution of frame types
plot_frame_distribution(frame_types, percentages)

"""Lab Task 3: Visualizing Frames

Objective:

Extract actual frames from the video and display them using Python.

Steps:

1.	Extract Frames:
o	Use ffmpeg to extract individual I, P, and B frames from the video.
o	Save these frames as image files.
2.	Display Frames:
o	Use a library like PIL (Pillow) or opencv-python to display the extracted frames.
"""

import ffmpeg
import os
import matplotlib.image as mpimg

# Create a directory to save frames
frames_dir = 'extracted_frames1'
if not os.path.exists(frames_dir):
    os.makedirs(frames_dir)

# Path to the video file
video_path = '/content/vid2.mp4'

# Extract frames and save as images
def extract_frames(video_path, frames_dir):
    try:
        (
            ffmpeg
            .input(video_path)
            .output(os.path.join(frames_dir, 'frame_%04d.jpeg'), qscale=0, vf='select=eq(pict_type\,I)+eq(pict_type\,P)+eq(pict_type\,B)')
            .run()
        )
        print("Frames extracted successfully.")
    except ffmpeg.Error as e:
        print(f"Error extracting frames: {e.stderr.decode('utf8')}")

# Display frames using matplotlib
def display_frames(frames_dir):
    frame_files = sorted([os.path.join(frames_dir, f) for f in os.listdir(frames_dir) if f.endswith('.png')])
    for frame_file in frame_files:
        frame = mpimg.imread(frame_file)
        plt.imshow(frame)
        plt.axis('off')
        plt.show()

extract_frames(video_path, frames_dir)
display_frames(frames_dir)

!zip -r /content/file.zip /content/extracted_frames1

"""Lab Task 3: Visualizing Frames

Objective:

Extract actual frames from the video and display them using Python.

Steps:

1.Extract Frames:
oUse ffmpeg to extract individual I, P, and B frames from the video.
oSave these frames as image files.

2.Display Frames:
oUse a library like PIL (Pillow) or opencv-python to display the extracted frames.

Tasks:

1.Save I, P, and B frames as separate image files using ffmpeg.

2.Use PIL or opencv-python to load and display these frames in a Python script.
3.Compare the visual quality of I, P, and B frames.
"""

# Create directories to save the frames
os.makedirs('I_frames', exist_ok=True)
os.makedirs('P_frames', exist_ok=True)
os.makedirs('B_frames', exist_ok=True)

# Extract I frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,I)'" -vsync vfr I_frames/frame_%04d.jpeg

# Extract P frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,P)'" -vsync vfr P_frames/frame_%04d.jpeg

# Extract B frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,B)'" -vsync vfr B_frames/frame_%04d.jpeg

def display_frames(frame_folder, title):
    images = sorted(os.listdir(frame_folder))
    for image in images[:5]:  # Display the first 5 frames as an example
        img = cv2.imread(os.path.join(frame_folder, image))
        if img is None:
            print(f"Error reading image {image}")
            continue
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        plt.imshow(img_rgb)
        plt.title(f'{title} - {image}')
        plt.axis('off')
        plt.show()

# Display I frames
display_frames('I_frames', 'I Frame')

# Display P frames
display_frames('P_frames', 'P Frame')

# Display B frames
display_frames('B_frames', 'B Frame')

from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
import cv2

def compare_frames(frame1_path, frame2_path):
    frame1 = cv2.imread(frame1_path)
    frame2 = cv2.imread(frame2_path)

    if frame1 is None:
        raise ValueError(f"Error reading frame1: {frame1_path}")
    if frame2 is None:
        raise ValueError(f"Error reading frame2: {frame2_path}")

    # Resize frames if they are too small
    min_size = 7  # Minimum size for SSIM window
    if frame1.shape[0] < min_size or frame1.shape[1] < min_size:
        frame1 = cv2.resize(frame1, (min_size, min_size))
    if frame2.shape[0] < min_size or frame2.shape[1] < min_size:
        frame2 = cv2.resize(frame2, (min_size, min_size))

    psnr_value = psnr(frame1, frame2)
    ssim_value, _ = ssim(frame1, frame2, full=True, multichannel=True, win_size=3)  # Use a smaller window size

# Check if the files exist
if not os.path.exists(i_frame_path):
    print(f"File does not exist: {i_frame_path}")
if not os.path.exists(p_frame_path):
    print(f"File does not exist: {p_frame_path}")

# Perform the comparison if the files exist
if os.path.exists(i_frame_path) and os.path.exists(p_frame_path):
    psnr_value, ssim_value = compare_frames(i_frame_path, p_frame_path)
    print(f'PSNR: {psnr_value}, SSIM: {ssim_value}')

!zip -r /content/B_frames.zip /content/B_frames

!zip -r /content/I_frames.zip /content/I_frames

!zip -r /content/P_frames.zip /content/P_frames

"""Lab Task 4: Frame Compression Analysis

Objective:

Analyze the compression efficiency of I, P, and B frames.

Steps:

1.Calculate Frame Sizes:
oCalculate the file sizes of extracted I, P, and B frames.
oCompare the average file sizes of each frame type.

2.Compression Efficiency:
oDiscuss the role of each frame type in video compression.
oAnalyze why P and B frames are generally smaller than I frames.
"""

def get_frame_sizes(directory):
    frame_sizes = []
    for filename in os.listdir(directory):
        if filename.endswith('.jpeg'):
            filepath = os.path.join(directory, filename)
            frame_size = os.path.getsize(filepath)
            frame_sizes.append(frame_size)
    return frame_sizes

# Get frame sizes
I_FRAME_SIZES = get_frame_sizes('I_frames')
P_FRAME_SIZES = get_frame_sizes('P_frames')
B_FRAME_SIZES = get_frame_sizes('B_frames')

# Calculate average sizes
AVG_I_FRAME_SIZE = sum(I_FRAME_SIZES) / len(I_FRAME_SIZES) if I_FRAME_SIZES else 0
AVG_P_FRAME_SIZE = sum(P_FRAME_SIZES) / len(P_FRAME_SIZES) if P_FRAME_SIZES else 0
AVG_B_FRAME_SIZE = sum(B_FRAME_SIZES) / len(B_FRAME_SIZES) if B_FRAME_SIZES else 0

# Print results
print(f'AVERAGE I-FRAME SIZE: {AVG_I_FRAME_SIZE:.2f} BYTES')
print(f'AVERAGE P-FRAME SIZE: {AVG_P_FRAME_SIZE:.2f} BYTES')
print(f'AVERAGE B-FRAME SIZE: {AVG_B_FRAME_SIZE:.2f} BYTES')

"""Lab Task 5: Advanced Frame Extraction

Objective:

Extract frames from a video and reconstruct a part of the video using only I frames.

Steps:

1.Extract and Save I Frames:
oExtract I frames from the video and save them as separate image files.

2.Reconstruct Video:
oUse the extracted I frames to reconstruct a portion of the video.
oCreate a new video using these I frames with a reduced frame rate.
"""
import subprocess

# Define the input video file path
video_path = '/content/vid2.mp4'

# Create a directory to save the I-frames
i_frames_dir = 'I_frames'
os.makedirs(i_frames_dir, exist_ok=True)

# Extract I-frames
subprocess.run([
    'ffmpeg', '-i', video_path, '-vf', "select='eq(pict_type\,I)'", '-vsync', 'vfr', os.path.join(i_frames_dir, 'frame_%04d.png')
])

# Reconstruct video using the extracted I-frames
output_video_path = 'reconstructed_video.mp4'
frame_rate = 1  # Reduced frame rate (frames per second)

subprocess.run([
    'ffmpeg', '-framerate', str(frame_rate), '-i', os.path.join(i_frames_dir, 'frame_%04d.png'), '-c:v', 'libx264', '-pix_fmt', 'yuv420p', output_video_path
])