# -*- coding: utf-8 -*-
"""IVALAB2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yGlrgdb6rZG-nebhstent64mLp3PFd59

CSE4076-Image and Video Analytics

Lab Experiment 2

Reg.No.: 21MIA1114

Name: S Deepak Kumar

GITHUB link for python file: https://github.com/Deepak30j/IVA/tree/LAB2
"""

pip install ffmpeg-python

"""Lab Task 1: Setup and Basic Extraction

Objective:

Install the necessary tools and libraries, and extract frame information from a video.

Steps:

1.	Install ffmpeg and ffmpeg-python:
o	Install the ffmpeg tool and the ffmpeg-python library.
2.	Extract Frame Information:
o	Extract frame information from a sample video.
"""

import ffmpeg

# Path to the video file
video_path = '/content/vid2.mp4'

# Get video information
probe = ffmpeg.probe(video_path)
video_info = next(stream for stream in probe['streams'] if stream['codec_type'] == 'video')

# Extract frame information
frame_rate = eval(video_info['r_frame_rate'])
duration = float(video_info['duration'])
total_frames = int(frame_rate * duration)
width = int(video_info['width'])
height = int(video_info['height'])

print(f"Frame Rate: {frame_rate} frames per second")
print(f"Duration: {duration} seconds")
print(f"Total Frames: {total_frames}")
print(f"Width: {width} pixels")
print(f"Height: {height} pixels")

"""Lab Task 2: Frame Type Analysis

Objective:

Analyze the extracted frame information to understand the distribution of I, P, and B frames in a video.

Steps:

1.Modify the Script:
oCount the number of I, P, and B frames.
oCalculate the percentage of each frame type in the video.

2.Analyze Frame Distribution:
oPlot the distribution of frame types using a library like matplotlib.
oPlot a pie chart or bar graph showing the distribution of frame types using matplotlib.
"""

import ffmpeg
import matplotlib.pyplot as plt

def count_frame_types(video_path):
    # Use ffmpeg to count I, P, and B frames
    result = ffmpeg.probe(video_path, select_streams='v', show_frames=None, show_entries='frame=pict_type')
    frames = result['frames']
    # Count the number of I, P, B frames
    frame_types = {'I': 0, 'P': 0, 'B': 0}
    for frame in frames:
        frame_type = frame['pict_type']
        frame_types[frame_type] += 1
    total_frames = sum(frame_types.values())
    percentages = {frame_type: (count / total_frames) * 100 for frame_type, count in frame_types.items()}
    print(f"I-Frames: {frame_types['I']} ({percentages['I']:.2f}%)")
    print(f"P-Frames: {frame_types['P']} ({percentages['P']:.2f}%)")
    print(f"B-Frames: {frame_types['B']} ({percentages['B']:.2f}%)")
    return frame_types, percentages
def plot_frame_distribution(frame_types, percentages):
    labels = ['I-Frames', 'P-Frames', 'B-Frames']
    counts = [frame_types['I'], frame_types['P'], frame_types['B']]
    percent_values = [percentages['I'], percentages['P'], percentages['B']]
    # Bar Plot
    plt.figure(figsize=(10, 5))
    plt.bar(labels, counts, color=['green', 'blue', 'red'])
    plt.xlabel('Frame Type')
    plt.ylabel('Count')
    plt.title('Frame Type Distribution')
    plt.show()

    # Pie Chart
    plt.figure(figsize=(8, 8))
    plt.pie(counts, labels=labels, autopct='%1.1f%%', colors=['green', 'blue', 'red'])
    plt.title('Frame Type Distribution')
    plt.show()
video_path = '/content/vid2.mp4'
# Count frame types and calculate percentages
frame_types, percentages = count_frame_types(video_path)
# Plot the distribution of frame types
plot_frame_distribution(frame_types, percentages)

"""Lab Task 3: Visualizing Frames

Objective:

Extract actual frames from the video and display them using Python.

Steps:

1.	Extract Frames:
o	Use ffmpeg to extract individual I, P, and B frames from the video.
o	Save these frames as image files.
2.	Display Frames:
o	Use a library like PIL (Pillow) or opencv-python to display the extracted frames.
"""

import ffmpeg
import os
import matplotlib.image as mpimg

# Create a directory to save frames
frames_dir = 'extracted_frames1'
if not os.path.exists(frames_dir):
    os.makedirs(frames_dir)

# Path to the video file
video_path = '/content/vid2.mp4'

# Extract frames and save as images
def extract_frames(video_path, frames_dir):
    try:
        (
            ffmpeg
            .input(video_path)
            .output(os.path.join(frames_dir, 'frame_%04d.jpeg'), qscale=0, vf='select=eq(pict_type\,I)+eq(pict_type\,P)+eq(pict_type\,B)')
            .run()
        )
        print("Frames extracted successfully.")
    except ffmpeg.Error as e:
        print(f"Error extracting frames: {e.stderr.decode('utf8')}")

# Display frames using matplotlib
def display_frames(frames_dir):
    frame_files = sorted([os.path.join(frames_dir, f) for f in os.listdir(frames_dir) if f.endswith('.png')])
    for frame_file in frame_files:
        frame = mpimg.imread(frame_file)
        plt.imshow(frame)
        plt.axis('off')
        plt.show()

extract_frames(video_path, frames_dir)
display_frames(frames_dir)

!zip -r /content/file.zip /content/extracted_frames1

"""
2.Display Frames:
oUse a library like PIL (Pillow) or opencv-python to display the extracted frames.

Tasks:

1.Save I, P, and B frames as separate image files using ffmpeg.

2.Use PIL or opencv-python to load and display these frames in a Python script.
3.Compare the visual quality of I, P, and B frames.
"""
import os
import ffmpeg
import cv2
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.metrics import mean_squared_error as mse

# Create directories to save the frames
os.makedirs('I_frames', exist_ok=True)
os.makedirs('P_frames', exist_ok=True)
os.makedirs('B_frames', exist_ok=True)

# Path to the video file
video_path = '/content/vid2.mp4'

# Extract I frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,I)'" -vsync vfr I_frames/frame_%04d.jpeg

# Extract P frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,P)'" -vsync vfr P_frames/frame_%04d.jpeg

# Extract B frames
!ffmpeg -i "{video_path}" -vf "select='eq(pict_type\,B)'" -vsync vfr B_frames/frame_%04d.jpeg

def display_frames(frame_folder, title):
    images = sorted(os.listdir(frame_folder))
    for image in images[:5]:  # Display the first 5 frames as an example
        img = cv2.imread(os.path.join(frame_folder, image))
        if img is None:
            print(f"Error reading image {image}")
            continue
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        plt.imshow(img_rgb)
        plt.title(f'{title} - {image}')
        plt.axis('off')
        plt.show()

# Display I frames
display_frames('I_frames', 'I Frame')

# Display P frames
display_frames('P_frames', 'P Frame')

# Display B frames
display_frames('B_frames', 'B Frame')

def compare_frames(frame1_path, frame2_path):
    frame1 = cv2.imread(frame1_path)
    frame2 = cv2.imread(frame2_path)

    if frame1 is None:
        raise ValueError(f"Error reading frame1: {frame1_path}")
    if frame2 is None:
        raise ValueError(f"Error reading frame2: {frame2_path}")

    # Resize frames if they are too small
    min_size = 7  # Minimum size for SSIM window
    if frame1.shape[0] < min_size or frame1.shape[1] < min_size:
        frame1 = cv2.resize(frame1, (min_size, min_size))
    if frame2.shape[0] < min_size or frame2.shape[1] < min_size:
        frame2 = cv2.resize(frame2, (min_size, min_size))

    psnr_value = psnr(frame1, frame2)
    ssim_value, _ = ssim(frame1, frame2, full=True, multichannel=True, win_size=3)  # Use a smaller window size
    mse_value = mse(frame1, frame2)

    return psnr_value, ssim_value, mse_value

# Example frame paths (update these with actual paths to I, P, B frames)
i_frame_path = 'I_frames/frame_0001.jpeg'  # Update with actual path
p_frame_path = 'P_frames/frame_0001.jpeg'  # Update with actual path
b_frame_path = 'B_frames/frame_0001.jpeg'  # Update with actual path

# Compare frames
if os.path.exists(i_frame_path) and os.path.exists(p_frame_path):
    psnr_value, ssim_value, mse_value = compare_frames(i_frame_path, p_frame_path)
    print(f'PSNR between I and P frame: {psnr_value:.2f}')
    print(f'SSIM between I and P frame: {ssim_value:.4f}')
    print(f'MSE between I and P frame: {mse_value:.2f}')

if os.path.exists(i_frame_path) and os.path.exists(b_frame_path):
    psnr_value, ssim_value, mse_value = compare_frames(i_frame_path, b_frame_path)
    print(f'PSNR between I and B frame: {psnr_value:.2f}')
    print(f'SSIM between I and B frame: {ssim_value:.4f}')
    print(f'MSE between I and B frame: {mse_value:.2f}')

if os.path.exists(p_frame_path) and os.path.exists(b_frame_path):
    psnr_value, ssim_value, mse_value = compare_frames(p_frame_path, b_frame_path)
    print(f'PSNR between P and B frame: {psnr_value:.2f}')
    print(f'SSIM between P and B frame: {ssim_value:.4f}')
    print(f'MSE between P and B frame: {mse_value:.2f}')

!zip -r /content/B_frames.zip /content/B_frames
!zip -r /content/I_frames.zip /content/I_frames
!zip -r /content/P_frames.zip /content/P_frames

"""Lab Task 4: Frame Compression Analysis

Objective:

Analyze the compression efficiency of I, P, and B frames.

Steps:

1.Calculate Frame Sizes:
oCalculate the file sizes of extracted I, P, and B frames.
oCompare the average file sizes of each frame type.

2.Compression Efficiency:
oDiscuss the role of each frame type in video compression.
oAnalyze why P and B frames are generally smaller than I frames.
"""

def get_frame_sizes(directory):
    frame_sizes = []
    for filename in os.listdir(directory):
        if filename.endswith('.jpeg'):
            filepath = os.path.join(directory, filename)
            frame_size = os.path.getsize(filepath)
            frame_sizes.append(frame_size)
    return frame_sizes

# Get frame sizes
I_FRAME_SIZES = get_frame_sizes('I_frames')
P_FRAME_SIZES = get_frame_sizes('P_frames')
B_FRAME_SIZES = get_frame_sizes('B_frames')

# Calculate average sizes
AVG_I_FRAME_SIZE = sum(I_FRAME_SIZES) / len(I_FRAME_SIZES) if I_FRAME_SIZES else 0
AVG_P_FRAME_SIZE = sum(P_FRAME_SIZES) / len(P_FRAME_SIZES) if P_FRAME_SIZES else 0
AVG_B_FRAME_SIZE = sum(B_FRAME_SIZES) / len(B_FRAME_SIZES) if B_FRAME_SIZES else 0

# Print results
print(f'AVERAGE I-FRAME SIZE: {AVG_I_FRAME_SIZE:.2f} BYTES')
print(f'AVERAGE P-FRAME SIZE: {AVG_P_FRAME_SIZE:.2f} BYTES')
print(f'AVERAGE B-FRAME SIZE: {AVG_B_FRAME_SIZE:.2f} BYTES')

"""COMPRESSION EFFICIENCY ANALYSIS:
I-FRAMES (INTRA-CODED FRAMES):

Keyframes with full image data, resulting in larger file sizes.
Serve as reference points for P and B frames.
Compression Efficiency: Low
P-FRAMES (PREDICTED FRAMES):

Contain only the differences from preceding I or P frames.
Utilize motion vectors to reduce size.
Compression Efficiency: Medium
B-FRAMES (BI-DIRECTIONAL PREDICTED FRAMES):

Contain differences from both preceding and following I or P frames.
Achieve the highest compression efficiency by leveraging surrounding frames.
Compression Efficiency: High
"""

"""Lab Task 5: Advanced Frame Extraction

Objective:

Extract frames from a video and reconstruct a part of the video using only I frames.

Steps:

1.Extract and Save I Frames:
oExtract I frames from the video and save them as separate image files.

2.Reconstruct Video:
oUse the extracted I frames to reconstruct a portion of the video.
oCreate a new video using these I frames with a reduced frame rate.
"""
import subprocess

# Define the input video file path
video_path = '/content/vid2.mp4'

# Create a directory to save the I-frames
i_frames_dir = 'I_frames'
os.makedirs(i_frames_dir, exist_ok=True)

# Extract I-frames
subprocess.run([
    'ffmpeg', '-i', video_path, '-vf', "select='eq(pict_type\,I)'", '-vsync', 'vfr', os.path.join(i_frames_dir, 'frame_%04d.png')
])

# Reconstruct video using the extracted I-frames
output_video_path = 'reconstructed_video.mp4'
frame_rate = 1  # Reduced frame rate (frames per second)

subprocess.run([
    'ffmpeg', '-framerate', str(frame_rate), '-i', os.path.join(i_frames_dir, 'frame_%04d.png'), '-c:v', 'libx264', '-pix_fmt', 'yuv420p', output_video_path
])

import os
import cv2
import numpy as np
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
from skimage.metrics import mean_squared_error as mse
import subprocess

# Paths to the videos
original_video_path = '/content/vid2.mp4'
reconstructed_video_path = 'reconstructed_video.mp4'

# Directories to save the extracted frames
original_frames_dir = 'original_frames'
reconstructed_frames_dir = 'reconstructed_frames'
os.makedirs(original_frames_dir, exist_ok=True)
os.makedirs(reconstructed_frames_dir, exist_ok=True)

# Extract frames from the original video at regular intervals (every 1 second)
subprocess.run([
    'ffmpeg', '-i', original_video_path, '-vf', "fps=1", os.path.join(original_frames_dir, 'frame_%04d.png')
])

# Extract frames from the reconstructed video at regular intervals (every 1 second)
subprocess.run([
    'ffmpeg', '-i', reconstructed_video_path, '-vf', "fps=1", os.path.join(reconstructed_frames_dir, 'frame_%04d.png')
])

def compare_frames(original_frame_path, reconstructed_frame_path):
    original_frame = cv2.imread(original_frame_path)
    reconstructed_frame = cv2.imread(reconstructed_frame_path)

    if original_frame is None:
        raise ValueError(f"Error reading original frame: {original_frame_path}")
    if reconstructed_frame is None:
        raise ValueError(f"Error reading reconstructed frame: {reconstructed_frame_path}")

    # Resize frames to match each other if needed
    if original_frame.shape != reconstructed_frame.shape:
        reconstructed_frame = cv2.resize(reconstructed_frame, (original_frame.shape[1], original_frame.shape[0]))

    psnr_value = psnr(original_frame, reconstructed_frame)
    ssim_value, _ = ssim(original_frame, reconstructed_frame, full=True, multichannel=True, win_size=3)  # Use a smaller window size
    mse_value = mse(original_frame, reconstructed_frame)

    return psnr_value, ssim_value, mse_value

# Get sorted list of frames
original_frames = sorted([os.path.join(original_frames_dir, f) for f in os.listdir(original_frames_dir) if f.endswith('.png')])
reconstructed_frames = sorted([os.path.join(reconstructed_frames_dir, f) for f in os.listdir(reconstructed_frames_dir) if f.endswith('.png')])

# Ensure we compare only up to the minimum number of frames available in both directories
min_frames = min(len(original_frames), len(reconstructed_frames))
original_frames = original_frames[:min_frames]
reconstructed_frames = reconstructed_frames[:min_frames]

# Compare frames and calculate average PSNR, SSIM, and MSE
psnr_values = []
ssim_values = []
mse_values = []

for original_frame, reconstructed_frame in zip(original_frames, reconstructed_frames):
    try:
        psnr_value, ssim_value, mse_value = compare_frames(original_frame, reconstructed_frame)
        psnr_values.append(psnr_value)
        ssim_values.append(ssim_value)
        mse_values.append(mse_value)
    except ValueError as e:
        print(f"Skipping frame pair due to error: {e}")

# Calculate and print average values
avg_psnr = np.mean(psnr_values)
avg_ssim = np.mean(ssim_values)
avg_mse = np.mean(mse_values)

print(f'Average PSNR: {avg_psnr:.2f}')
print(f'Average SSIM: {avg_ssim:.4f}')
print(f'Average MSE: {avg_mse:.2f}')